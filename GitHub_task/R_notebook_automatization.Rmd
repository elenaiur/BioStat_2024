---
title: "r_automatisation"
output:
  html_document: default
  word_document: default
date: "`r format(Sys.time(), '%d %B, %Y')`"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library (tidyverse)
library (dplyr)
library (stringr)
library (flextable)
```
### Поиск информации в сети 

Функция ```RSiteSearch()``` перенаправляет на search.r-project.org, где представлена информация по искомому термину. Обратите внимание, что термин должен быть заключён в кавычки. Пример: ```RSiteSearch("biostatistics")```:

### Аспекты использования R Studio

##### find-replace

**Find** — это поле, в которое вводится искомый паттерн из символов, или, простыми словами, искомое слово; \
**Replace** — это поле, в которое вводится паттерн, на который заменяется паттерн из Find; \
**Next, Prev, All** соответственно переключают на следующий искомый паттерн, предыдущий или выбирают все сразу;\
**Replace, All** выбирают, производить ли замену только в одном случае или сразу во всех. При этом, если нажимать Replace раз за разом, то замена будет производиться для следующего паттерна;\
**In selection** переключает поиск в режим "искать только в выделенном заранее сегменте";\
**Match case** -учитывать регистр (большая буква или маленькая) или нет;
**Whole word** -искать ли только слово целиком или включить в результат слова, внутри которых находится искомое слово;\
**Regex** переключает поиск в режим регулярных выражений.\
Интересный факт: если мы хотим добавить к строке какую-то ещё строку, например, ко всем "data" добавить "data_c1", нам достаточно заменить строку "data" на строку "data_c1".

##### Кнопка полной очистки памяти
Удалит все данные, переменные и функции. Её стоит использовать, когда мы хотим выполнить весь код заново, чтобы убедиться, что он работает без ошибок.

##### Структура папки проекта
Прежде всего, для чистоты проекта лучше создавать папку **data** рядом с остальными вышеперечисленными файлами. Уже в ней можно создать следующие папки:\
**originals** — сюда просто складываем все исходные файлы, нужные для проекта. Важной особенностью этой папки должно являться то, что файлы в ней мы ни в коем случае не меняем. Таким образом всегда останется резервная чистая копия, если что-то пойдёт не так в других папках. Для работы с файлами мы просто копируем файлы из этой папки в другие;\
**pics** — сюда сохраняем картинки/графики и прочую графическую информацию, появляющуюся в ходе анализа;\
**raw** — сырые файлы данных. Именно из этой папки мы будем читать данные и загружать их в R для последующего анализа. В ней так же не стоит менять файлы, чтобы гарантировать, что все изменения, проводимые в R, проводятся на основе тех же данных, что есть у коллег;\
**documents** — здесь лежит вся документация, такая как протоколы, SAPы (планы статистического анализа), листы регистрации и подобное.\

### Структура R Markdown

##### Заголовок

**Заголовок YAML**, окружённый ---, он не обязательно должен присутствовать, но в нём можно указывать (ниже примеры):\

Пример YAML-заголовка\
Заголовок : title: "Example title" — отображается в начале документа большим шрифтом;\
Подзаголовок: subtitle: "Example subtitle" — отображается под заголовком шрифтом поменьше;\
Автор: author: "User Name";\
Дата: date: "r Sys.Date()" — в данном примере дата будет обновляться при каждом выводе документа в печать;\
Вывод: output: word_document — в данном примере вывод настроен на вывод документа формата .docx.\
Чанки. Вставляются с помощью **Ctrl + Alt + I** или просто с помощью написания 
```{r eval =F}
```в начале чанка и закрывающих  в конце чанка```
```
##### Чанк
 В фигурных скобках после указания r как используемого в чанке языка можно через пробел указать название чанка, чтобы позже было проще ориентироваться;
Шестерёнка в правом верхнем углу позволяет настраивать в графическом режиме параметры чанков;\
Кнопка в виде белого треугольника с зелёной полоской выполнит все фрагменты кода выше данного текущего чанка. Также можно сделать с помощью постановки курсора в чанк и горячих клавишей **Ctrl + Alt + P**;\
Крайний правый зелёный треугольник просто выполнит весь код в чанке.\

**echo = TRUE** — показывать ли код при печати документа. Обычно это не нужно, поэтому есть смысл установить FALSE;\
error = FALSE — показывать ли при печати ошибки;\
**eval = TRUE** — выполнять ли код в чанке. Обычно мы действительно хотим, чтобы код в чанке выполнялся, однако иногда есть смысл временно или навсегда выключить один или несколько чанков из кода.\
**fig.width  = 7 и fig.height = 7** \

##### Первый чанк
В нём же следует писать и код подключения пакетов.\
Сюда же можно рекомендовать класть и собственноручно написанные функции с тем, чтобы они автоматически подгружались при запуске и чтобы не случилось внезапно так, что функция используется раньше, чем будет объявлена.

##### Текст
```{r eval =FALSE}
`r mean (1:10)` кусок кода будет вычислен в тексте
```

1) Первый элемент
  1) Первый вложенный
  2) Второй вложенный
  
- Ненумерованный 
  - Первый вложенный ненумернованный
  - Второй вложенный ненумернованный

##### Создание автоматического оглавления: toc, toc-title\
Для этого используется параметр **toc: yes**. 

Дополнительно можно ограничить количество возможных уровней списков в оглавлении с помощью соответствующего параметра. В примере количество уровней ограничено тремя: toc_depth: 3.

Наконец, по умолчанию заголовок оглавления будет "Table of Contents", но зачастую мы хотим изменить его. Для этого используется параметр toc-title: "Оглавление" как в примере. Обратите внимание, что, в отличие от остальных параметров, связанных с автоматическим оглавлением, этот параметр пишется без отступов.

### Пакеты
##### Две функции для подключения пакетов к текущему проекту 

**library(package_name)** (название пакета можно писать без кавычек) — основная функция, которой стоит пользоваться всегда. Дело в том, что в случае, если пакет ещё не установлен, эта функция вернёт ошибку и прервёт выполнение кода. Таким образом мы не окажемся в ситуации, когда обнаружим отсутствие нужных функций уже тогда, когда напишем какой-то работающий частично код;

**require(package_name)** — эта функция возвращает FALSE вместо ошибки, что удобно, когда мы пишем сложные функции, зависящие от наличия возможности подключить пакет.

Но, если мы по какой-то причине не хотим явно подключать проект, можно использовать функции напрямую из установленного пакета с помощью синтаксиса packagename::functionname(). Например: ```dplyr::select()```.

Отключение  ```detach(package:dplyr)```. В этом примере мы выгружаем пакет dplyr и его функции становятся недоступны. Внутри функции обязательно нужно писать package: (с двоеточием), а потом название пакета без кавычек.

##### dplyr 

Основные его функции (глаголы, говорящие, что именно мы делаем):

mutate() — изменяет переменные, добавляет новые;\
select() — выбирает переменные;\
filter() — фильтрует объекты по условиям;\
summarise() — вычисляет сводные статистики;\
arrange() — сортирует по переменным;\
group_by() — группирует по значениям переменных;\
*_join() — группа глаголов для склеивания двух таблиц по ключу.\

##### tidyr 

Поворачивать данные, то есть, преобразовывать их в длинный и широкий форматы: pivot_longer(), pivot_wider();\
Разворачивать данные из вложенных списков в простые таблицы: unnest_longer(), unnest_wider();\
Наоборот, делать из таблиц вложенные переменные: nest(), unnest();\
Разделять и объединять столбцы по разделителю строк: separate(), unite();\
Заполнять отсутствующие значения определёнными значениями или удалять их: complete(), drop_na(), fill(), replace_na().

##### readr, readxl, haven

Три основных пакета, которые помогают читать данные.
readr предназначен для чтения самых распространённых форматов данных: .csv, .txt, *.tsv;\
redxl помогает читать файлы *.xlsx или, иными словами, всё, что пересылается в формате Excel;\
haven читает форматы *.sas7bdat, .sap, .dta, .sav, .por, то есть данные из SAS.\

##### purrr

Этот пакет может поначалу казаться сложным для понимания, однако на самом деле он просто расширяет функционал уже известного семейства функций **apply()**. Функция **map()** и её расширения позволяют итерироваться по элементам векторов или списков самыми разными способами.

##### tibble

1) **tibble** в отличие data.frame он не приводит строки к факторам автоматически. Это нужно сделать самостоятельно, однако таким образом мы всегда в точности знаем, что находится в каждой переменной датафрейма;
2) Имена переменных остаются такими же, какими были. Например, в переменной с названием "variable name" пробел не будет заменён на точку, вместо этого имя будет окружено апострофами (обычно находятся на букве "ё"), что сохраняет ожидания от названий;
3) tibble оценивает переменные лениво- при создании мы можем объявлять одну переменную на основе другой (но эта другая должна быть указана первой).

##### ggplot2 и ggpubr

Для визуализации данных существует сразу два пакета: базовый ggplot

Дополнительные интересные особенности вроде автоматического расчёта и добавления на график p-value, реализованы в пакете ggpubr.

##### flextable\
- печать статистических таблиц
##### stringr \
-  работа со строками
##### lubridate \
- работа с датами
##### DescTools, psych\
полезные функции для групп статистик, корреляционных матриц


### Загрузка дф
```{r}
data <- read_tsv("data_tsv.tsv", quote = "\"", )
data <-data %>% mutate (across (where(is.character), function (x) as.factor(x)))

```

### Выбор столбцов 

##### dplyr::select(), where()

Такие формы записи верны:

```{r , eval = F}

data %>% select(`Группа крови`, `Возраст`, function(x) anyNA(x))
data %>% select(`Группа`, function(x) !is.factor(x))
data %>% select(`Группа`, (function(x) is.factor(x)) | where(function(x) is.numeric(x)))
# data %>% select(function(x) any(str_detect(x, "Жен")))
```
Обратить внимание что если в результате проверки условия появляется  NA, то операция И/ИЛИ не проходит и будет ошибка, как тут:

 data %>% select(function(x) sd(x, na.rm = TRUE) > 1)  \
 часть переменных строковые и sd выдаст NA

##### tidyselect::contains(), tidyselect::matches(), tidyselect::starts_with(), tidyselect::ends_with()

##### tidyselect::all_of(), tidyselect::any_of()
Для того, чтобы функция выдавала ошибку, если отсутствует хотя бы одна из переменных, внутри select() следует использовать all_of().
Мы можем выбирать переменные более мягко - any_of().

##### Иерархия операторов

Приоритет логических операторов от высшего к низшему. 

x < y, x > y, x <= y, x => y, x == y, x != y (операторы сравнения)\
!x (логическое НЕ)\
x & y (логическое И)\
x | y (логическое ИЛИ)\

#####  tidyselect::everything()

Есть простая функция, которая просто значит "все остальные столбцы, кроме тех, которые уже были указаны". Например, так мы можем выбрать определённые столбцы, а потом просто все остальные, которые будут выведены в том порядке, в котором они были, за исключением тех, что мы уже явно взяли.

##### Выбор с одновременным изменением имён\
Мы можем выбирать переменные, одновременно изменяя их имена.

##### Почему стоит использовать имена, а не номера\
Если мы много времени провели, используя только базовый R, то может показаться хорошей идеей использовать индексы столбцов для их выбора.\
Но почему этого не стоит делать\
Этого не стоит делать, потому что местоположения столбцов могут меняться, а вот их имена мы скорее всего уже знаем.

### Расчёт статистик
##### list() из функций для расчёта списка статистик

```{r}
statistics <- list(
      `Количество субъектов` = ~length(.x) %>%as.character(),
      `Количество (есть данные)` = ~sum(!is.na(.x)) %>%as.character(),
      `Нет данных` = ~sum(is.na(.x)) %>% as.character(),
      `Ср. знач.` = ~ifelse(sum(!is.na(.x)) == 0, "Н/П*", mean(.x, na.rm = TRUE) %>% round(2) %>% as.character()),
      `Станд. отклон.` = ~ifelse(sum(!is.na(.x)) < 3, "Н/П*", sd(.x, na.rm = TRUE) %>% round(2) %>% as.character()),
      `95% ДИ для среднего` = ~sd(.x, na.rm = TRUE) %>% round(2) %>% as.character(),
      `мин. - макс.` = ~ifelse(sum(!is.na(.x)) == 0, "Н/П*", paste0(min(.x, na.rm = TRUE) %>% round(2), " - ", max(.x, na.rm = TRUE) %>% round(2))),
      `Медиана` = ~ifelse(sum(!is.na(.x)) == 0, "Н/П*", median(.x, na.rm = TRUE) %>% round(2) %>% as.character()),
      `Q1 - Q3` = ~ifelse(sum(!is.na(.x)) == 0, "Н/П*", paste0(quantile(.x, 0.25, na.rm = TRUE) %>% round(2), " - ", quantile(.x, 0.75, na.rm = TRUE) %>% round(2)))
)
```
Комментарии:\
Знак тильды (~) и .x внутри функции — это просто краткий способ записать function(x).\
sum(!is.na(.x)) — проверка на то, что, чтобы переменная не была пустой (нельзя забывать проверить всё, что только возможно, чтобы не получить неожиданную ошибку);\
Наконец, мы округляем все значения и приводим к строковому типу, чтобы избежать ошибок при дальнейшем сведении всех результатов в табличку.\

##### Формирование статистической таблицы для количественной переменной

```{r warning=FALSE , echo=FALSE}
data %>%
  select (`Группа`, where ( is.numeric)) %>%
  group_by (`Группа`) %>%
  summarise (across(where(is.numeric), statistics)) %>%
  pivot_longer (!`Группа`) %>%
  separate (name, into = c ("Переменная", "Статистика"), sep= "_") %>%
  rename (`Значение` = value)
```
##### Формирование статистической таблицы для категориальной переменной

```{r}
data %>% 
select (`Группа`, where (is.factor)) %>%
  mutate (`Группа крови` = `Группа крови` %>% as.character() %>%  replace_na("Нет данных")%>% as.factor ())%>%
count (`Группа` , `Группа крови` )%>%
 group_by (`Группа` ) %>%
  mutate (`Процент по группе` = (n/sum (n)) %>% round (4) %>%'*'(100) %>% str_c ("%")) %>%
  ungroup ()%>%
  mutate (`Процент по выборке` = (n/sum (n)) %>% round (4) %>%'*'(100) %>% str_c ("%"))
```


### Печать таблиц - Пакет flextable 

#####   установка темы : flextable::theme_box(), flextable::theme_booktabs(), flextable::theme_alafoli()

#####   установка темы : flextable::theme_box(), flextable::theme_booktabs(), flextable::theme_alafoli()

Они позволяют склеивать ячейки так, чтобы таблица приобрела читаемый вид. 

Это можно делать как просто указав столбец (в таком случае будут склеены все ячейки с одинаковым текстом), так и более сложным способом, например, указав функцию. 

##### flextable::align()
```align(subtable, i = NULL, j = NULL, align = c("left", "center", "right", "justify"), part = "body")```

##### flextable::color(), flextable::bg()

##### flextable::bold(), flextable::italic()
##### lextable::color(), flextable::bg()
функция width() позволяет устанавливать ширину столбцов вручную. 

Первая функция изменяет цвет текста, вторая же заливает цветом саму ячейку.

```{r , echo=FALSE }
data %>% 
select (`Группа`, where (is.factor)) %>%
  mutate (`Группа крови` =  `Группа крови` %>% as.character() %>%  replace_na("Пока нет данных")%>% as.factor ()) %>%
count (`Группа` , `Группа крови`) %>%
 group_by (`Группа` ) %>%
  mutate (`Процент по группе` = (n/sum (n)) %>% round (4) %>%'*'(100) %>% str_c ("%")) %>%
  ungroup ()%>%
  mutate (`Процент по выборке` = (n/sum (n)) %>% round (4) %>%'*'(100) %>% str_c ("%")) %>%
  flextable () %>%
  theme_alafoli()
```



